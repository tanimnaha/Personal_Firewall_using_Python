# Project Documentation: Web Application Vulnerability Scanner

## Overview

This is a comprehensive web application vulnerability scanner built with Python and Flask. It provides both a modern web interface and command-line functionality to detect common security vulnerabilities in web applications.

## Architecture

### Core Components

1. **scanner.py** - Main vulnerability detection engine

   - VulnerabilityScanner class with methods for different vulnerability types
   - Web crawling functionality using requests and BeautifulSoup
   - Payload testing and response analysis
   - Structured vulnerability reporting

2. **app.py** - Flask web application

   - Web interface for managing scans
   - REST API endpoints
   - Scan result storage and retrieval
   - User-friendly dashboard

3. **templates/** - HTML templates with Bootstrap UI
   - Responsive design with modern CSS
   - Real-time scan progress indicators
   - Detailed vulnerability reports
   - Scan history management

## Vulnerability Detection Methods

### 1. Cross-Site Scripting (XSS)

- **Method**: Payload injection in form fields
- **Payloads**: 10+ different XSS vectors including:
  - Basic script tags
  - Event handlers (onerror, onload, onfocus)
  - JavaScript: protocol
  - SVG/iframe injection
- **Detection**: Response content analysis for reflected payloads
- **Severity**: High

### 2. SQL Injection

- **Method**: Database-specific payload injection
- **Payloads**: 15+ SQL injection vectors for:
  - MySQL, PostgreSQL, SQL Server, Oracle, Access
  - Union-based, boolean-based, error-based techniques
- **Detection**: Error pattern matching using regex
- **Severity**: Critical

### 3. Cross-Site Request Forgery (CSRF)

- **Method**: CSRF token presence analysis
- **Detection**: Checks for common CSRF token field names
- **Tokens Checked**: csrf_token, csrf, \_token, authenticity_token, \_csrf
- **Severity**: Medium

### 4. Security Headers

- **Method**: HTTP header analysis
- **Headers Checked**:
  - X-Frame-Options (Clickjacking protection)
  - X-XSS-Protection
  - X-Content-Type-Options (MIME sniffing)
  - Strict-Transport-Security (HSTS)
  - Content-Security-Policy (CSP)
- **Severity**: Low

## Technical Implementation

### Web Crawling

- **Library**: requests + BeautifulSoup4
- **Strategy**: Breadth-first search with configurable depth
- **Form Discovery**: Automatic detection of input fields and parameters
- **Rate Limiting**: Configurable delays between requests
- **Error Handling**: Robust exception handling for network issues

### Data Storage

- **Format**: JSON files for simplicity and portability
- **Location**: data/ directory (auto-created)
- **Structure**: Structured vulnerability reports with metadata
- **Cleanup**: Manual deletion through web interface

### Web Interface

- **Framework**: Flask with Jinja2 templating
- **Styling**: Bootstrap 5 + Font Awesome icons
- **Features**:
  - Real-time scan progress
  - Vulnerability categorization by severity
  - Responsive design for mobile devices
  - Search and filter capabilities

## Security Considerations

### Ethical Usage

- **Target Restrictions**: Only scan owned or authorized systems
- **Rate Limiting**: Built-in delays to prevent server overload
- **Payload Safety**: Non-destructive test payloads only
- **Logging**: Comprehensive logging for audit trails

### Scanner Limitations

- **False Positives**: Pattern-based detection may produce false positives
- **WAF Evasion**: Basic payloads may be blocked by security systems
- **JavaScript**: Limited JavaScript execution analysis
- **Authentication**: No built-in authentication bypass

## Configuration Options

### Environment Variables (.env)

```
FLASK_DEBUG=True
SECRET_KEY=your-secret-key
MAX_SCAN_DEPTH=3
SCAN_TIMEOUT=30
REQUEST_DELAY=0.5
```

### Scanner Parameters

- **max_depth**: How deep to crawl (1-3 levels recommended)
- **timeout**: Request timeout in seconds
- **delay**: Delay between requests to avoid overwhelming servers

## API Documentation

### POST /api/scan

Start a new vulnerability scan

```json
{
  "url": "https://example.com",
  "max_depth": 2
}
```

**Response:**

```json
{
  "url": "https://example.com",
  "scan_time": "2025-01-01T12:00:00",
  "vulnerabilities": [...],
  "summary": {
    "total_vulnerabilities": 5,
    "critical": 1,
    "high": 2,
    "medium": 1,
    "low": 1
  }
}
```

### GET /api/results

Retrieve all scan results

```json
[
  {
    "url": "https://example.com",
    "scan_time": "2025-01-01T12:00:00",
    "filename": "scan_20250101_120000.json",
    "summary": {...}
  }
]
```

## Performance Metrics

### Typical Scan Times

- **Single Page**: 5-15 seconds
- **Small Site (2-3 pages)**: 30-60 seconds
- **Medium Site (5-10 pages)**: 2-5 minutes
- **Large Site (10+ pages)**: 5+ minutes

### Resource Usage

- **Memory**: 50-100 MB typical usage
- **CPU**: Low to moderate during active scanning
- **Network**: Configurable request rate (default: 2 requests/second)

## Extending the Scanner

### Adding New Vulnerability Types

1. Create detection method in VulnerabilityScanner class
2. Add payload lists and detection logic
3. Update scan_website method to include new checks
4. Add appropriate severity classification

### Custom Payloads

```python
# Add to scanner.py
custom_payloads = [
    "custom_payload_1",
    "custom_payload_2"
]
```

### Database Integration

Replace JSON storage with database:

1. Add SQLAlchemy or similar ORM
2. Create models for scans and vulnerabilities
3. Update save/load functions in app.py

## Troubleshooting

### Common Issues

1. **Module Import Errors**

   - Solution: `pip install -r requirements.txt`

2. **Permission Denied**

   - Solution: Ensure write permissions for data/ directory

3. **Connection Timeouts**

   - Solution: Increase timeout values or reduce scan depth

4. **False Positives**

   - Solution: Manual verification required for all findings

5. **Rate Limiting**
   - Solution: Increase delay between requests

### Debug Mode

Enable debug logging:

```python
import logging
logging.basicConfig(level=logging.DEBUG)
```

## Future Enhancements

### Planned Features

1. **Advanced XSS Detection**: DOM-based XSS analysis
2. **Authentication**: User accounts and scan history
3. **Reporting**: PDF/HTML report generation
4. **Scheduling**: Automated recurring scans
5. **Notifications**: Email alerts for critical findings
6. **API Keys**: Rate limiting and usage tracking
7. **Plugin System**: Extensible vulnerability modules

### Performance Improvements

1. **Async Scanning**: Concurrent request processing
2. **Caching**: Response caching for repeated scans
3. **Database**: Proper database with indexing
4. **Queue System**: Background job processing

## Compliance and Standards

### OWASP Top 10 Coverage

- ✅ A03: Injection (SQL Injection)
- ✅ A07: Cross-Site Scripting (XSS)
- ✅ A01: Broken Access Control (CSRF)
- ✅ A05: Security Misconfiguration (Headers)
- ❌ A02: Cryptographic Failures (Future)
- ❌ A04: Insecure Design (Manual review)
- ❌ A06: Vulnerable Components (Future)
- ❌ A08: Software Integrity Failures (Future)
- ❌ A09: Logging Failures (Future)
- ❌ A10: Server-Side Request Forgery (Future)

### Best Practices Implemented

- Input validation and sanitization
- Error handling and logging
- Rate limiting and respectful scanning
- Structured vulnerability reporting
- Severity-based risk classification
