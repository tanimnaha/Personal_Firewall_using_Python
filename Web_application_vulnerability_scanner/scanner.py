import requests
import re
import urllib.parse
from bs4 import BeautifulSoup
from typing import List, Dict, Any
import json
import time
from datetime import datetime
import logging

class VulnerabilityScanner:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        self.vulnerabilities = []
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "'><script>alert('XSS')</script>",
            "\"><script>alert('XSS')</script>",
            "<iframe src=javascript:alert('XSS')></iframe>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>"
        ]
        
        self.sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' OR 1=1#",
            "' UNION SELECT NULL--",
            "' AND 1=1--",
            "' AND 1=2--",
            "admin'--",
            "admin'/*",
            "' OR 'x'='x",
            "' OR 'a'='a",
            "') OR ('1'='1",
            "' OR 1=1 LIMIT 1--",
            "' OR 1=1 ORDER BY 1--",
            "' UNION ALL SELECT NULL--",
            "' UNION SELECT user()--"
        ]
        
        # Common error patterns for SQL injection detection
        self.sql_errors = [
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_.*",
            r"valid MySQL result",
            r"MySqlClient\.",
            r"PostgreSQL.*ERROR",
            r"Warning.*\Wpg_.*",
            r"valid PostgreSQL result",
            r"Npgsql\.",
            r"Driver.*SQL[\-\_\ ]*Server",
            r"OLE DB.*SQL Server",
            r"(\W|\A)SQL Server.*Driver",
            r"Warning.*mssql_.*",
            r"(\W|\A)SQL Server.*[0-9a-fA-F]{8}",
            r"Exception.*\WSystem\.Data\.SqlClient\.",
            r"Exception.*\WRoadhouse\.Cms\.",
            r"Microsoft Access Driver",
            r"JET Database Engine",
            r"Access Database Engine",
            r"ODBC Microsoft Access",
            r"Syntax error.*query expression",
            r"OracleClient\.",
            r"\bORA-[0-9][0-9][0-9][0-9]",
            r"Oracle error",
            r"Oracle.*Driver",
            r"Warning.*\Woci_.*",
            r"Warning.*\Wora_.*"
        ]

    def crawl_website(self, url: str, max_depth: int = 2) -> List[Dict]:
        """Crawl website to find forms and input fields"""
        try:
            forms_data = []
            visited_urls = set()
            urls_to_visit = [(url, 0)]
            
            while urls_to_visit:
                current_url, depth = urls_to_visit.pop(0)
                
                if current_url in visited_urls or depth > max_depth:
                    continue
                    
                visited_urls.add(current_url)
                
                try:
                    response = self.session.get(current_url, timeout=10)
                    if response.status_code != 200:
                        continue
                        
                    soup = BeautifulSoup(response.content, 'html.parser')
                    
                    # Find all forms
                    forms = soup.find_all('form')
                    for form in forms:
                        form_data = self._extract_form_data(form, current_url)
                        if form_data:
                            forms_data.append(form_data)
                    
                    # Find additional URLs to crawl
                    if depth < max_depth:
                        links = soup.find_all('a', href=True)
                        for link in links:
                            href = link['href']
                            if href.startswith('/'):
                                full_url = urllib.parse.urljoin(current_url, href)
                            elif href.startswith('http'):
                                full_url = href
                            else:
                                continue
                                
                            # Only crawl same domain
                            if urllib.parse.urlparse(full_url).netloc == urllib.parse.urlparse(url).netloc:
                                urls_to_visit.append((full_url, depth + 1))
                                
                except Exception as e:
                    logging.error(f"Error crawling {current_url}: {str(e)}")
                    continue
                    
            return forms_data
            
        except Exception as e:
            logging.error(f"Error in crawl_website: {str(e)}")
            return []

    def _extract_form_data(self, form, base_url: str) -> Dict:
        """Extract form data for testing"""
        try:
            action = form.get('action', '')
            method = form.get('method', 'get').lower()
            
            if action:
                if action.startswith('/'):
                    action = urllib.parse.urljoin(base_url, action)
                elif not action.startswith('http'):
                    action = urllib.parse.urljoin(base_url, action)
            else:
                action = base_url
            
            inputs = []
            for input_field in form.find_all(['input', 'textarea', 'select']):
                input_type = input_field.get('type', 'text')
                name = input_field.get('name', '')
                value = input_field.get('value', '')
                
                if name and input_type not in ['submit', 'button', 'image', 'reset']:
                    inputs.append({
                        'name': name,
                        'type': input_type,
                        'value': value
                    })
            
            return {
                'url': action,
                'method': method,
                'inputs': inputs,
                'original_url': base_url
            }
            
        except Exception as e:
            logging.error(f"Error extracting form data: {str(e)}")
            return None

    def test_xss_vulnerability(self, form_data: Dict) -> List[Dict]:
        """Test for XSS vulnerabilities"""
        vulnerabilities = []
        
        try:
            for payload in self.xss_payloads:
                # Test each input field
                for input_field in form_data['inputs']:
                    test_data = {}
                    
                    # Fill other fields with normal data
                    for field in form_data['inputs']:
                        if field['name'] == input_field['name']:
                            test_data[field['name']] = payload
                        else:
                            test_data[field['name']] = field['value'] or 'test'
                    
                    try:
                        if form_data['method'] == 'post':
                            response = self.session.post(form_data['url'], data=test_data, timeout=10)
                        else:
                            response = self.session.get(form_data['url'], params=test_data, timeout=10)
                        
                        # Check if payload is reflected in response
                        if payload in response.text:
                            vulnerabilities.append({
                                'type': 'XSS',
                                'severity': 'High',
                                'url': form_data['url'],
                                'parameter': input_field['name'],
                                'payload': payload,
                                'evidence': f"Payload '{payload}' reflected in response",
                                'timestamp': datetime.now().isoformat(),
                                'method': form_data['method'].upper()
                            })
                            break  # Found vulnerability, no need to test more payloads for this field
                            
                    except Exception as e:
                        logging.error(f"Error testing XSS: {str(e)}")
                        continue
                        
        except Exception as e:
            logging.error(f"Error in test_xss_vulnerability: {str(e)}")
            
        return vulnerabilities

    def test_sql_injection(self, form_data: Dict) -> List[Dict]:
        """Test for SQL injection vulnerabilities"""
        vulnerabilities = []
        
        try:
            for payload in self.sql_payloads:
                for input_field in form_data['inputs']:
                    test_data = {}
                    
                    # Fill other fields with normal data
                    for field in form_data['inputs']:
                        if field['name'] == input_field['name']:
                            test_data[field['name']] = payload
                        else:
                            test_data[field['name']] = field['value'] or 'test'
                    
                    try:
                        if form_data['method'] == 'post':
                            response = self.session.post(form_data['url'], data=test_data, timeout=10)
                        else:
                            response = self.session.get(form_data['url'], params=test_data, timeout=10)
                        
                        # Check for SQL error patterns
                        for error_pattern in self.sql_errors:
                            if re.search(error_pattern, response.text, re.IGNORECASE):
                                vulnerabilities.append({
                                    'type': 'SQL Injection',
                                    'severity': 'Critical',
                                    'url': form_data['url'],
                                    'parameter': input_field['name'],
                                    'payload': payload,
                                    'evidence': f"SQL error pattern detected: {error_pattern}",
                                    'timestamp': datetime.now().isoformat(),
                                    'method': form_data['method'].upper()
                                })
                                break
                                
                    except Exception as e:
                        logging.error(f"Error testing SQL injection: {str(e)}")
                        continue
                        
        except Exception as e:
            logging.error(f"Error in test_sql_injection: {str(e)}")
            
        return vulnerabilities

    def check_csrf_protection(self, form_data: Dict) -> List[Dict]:
        """Check for CSRF protection"""
        vulnerabilities = []
        
        try:
            # Check if form has CSRF token
            has_csrf_token = False
            csrf_fields = ['csrf_token', 'csrf', '_token', 'authenticity_token', '_csrf']
            
            for input_field in form_data['inputs']:
                if any(csrf_field in input_field['name'].lower() for csrf_field in csrf_fields):
                    has_csrf_token = True
                    break
            
            if not has_csrf_token and form_data['method'] == 'post':
                vulnerabilities.append({
                    'type': 'CSRF',
                    'severity': 'Medium',
                    'url': form_data['url'],
                    'parameter': 'N/A',
                    'payload': 'N/A',
                    'evidence': 'POST form lacks CSRF protection token',
                    'timestamp': datetime.now().isoformat(),
                    'method': form_data['method'].upper()
                })
                
        except Exception as e:
            logging.error(f"Error checking CSRF: {str(e)}")
            
        return vulnerabilities

    def check_security_headers(self, url: str) -> List[Dict]:
        """Check for missing security headers"""
        vulnerabilities = []
        
        try:
            response = self.session.get(url, timeout=10)
            headers = response.headers
            
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection missing',
                'X-XSS-Protection': 'XSS protection header missing',
                'X-Content-Type-Options': 'MIME type sniffing protection missing',
                'Strict-Transport-Security': 'HTTPS enforcement missing',
                'Content-Security-Policy': 'Content Security Policy missing'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    vulnerabilities.append({
                        'type': 'Security Headers',
                        'severity': 'Low',
                        'url': url,
                        'parameter': header,
                        'payload': 'N/A',
                        'evidence': description,
                        'timestamp': datetime.now().isoformat(),
                        'method': 'GET'
                    })
                    
        except Exception as e:
            logging.error(f"Error checking security headers: {str(e)}")
            
        return vulnerabilities

    def scan_website(self, url: str, max_depth: int = 2) -> Dict:
        """Main scanning function"""
        scan_results = {
            'url': url,
            'scan_time': datetime.now().isoformat(),
            'vulnerabilities': [],
            'summary': {
                'total_vulnerabilities': 0,
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0
            }
        }
        
        try:
            # Crawl website
            forms = self.crawl_website(url, max_depth)
            
            # Test each form
            for form_data in forms:
                # Test XSS
                xss_vulns = self.test_xss_vulnerability(form_data)
                scan_results['vulnerabilities'].extend(xss_vulns)
                
                # Test SQL Injection
                sql_vulns = self.test_sql_injection(form_data)
                scan_results['vulnerabilities'].extend(sql_vulns)
                
                # Check CSRF
                csrf_vulns = self.check_csrf_protection(form_data)
                scan_results['vulnerabilities'].extend(csrf_vulns)
                
                # Small delay between tests
                time.sleep(0.5)
            
            # Check security headers
            header_vulns = self.check_security_headers(url)
            scan_results['vulnerabilities'].extend(header_vulns)
            
            # Calculate summary
            for vuln in scan_results['vulnerabilities']:
                severity = vuln['severity'].lower()
                scan_results['summary'][severity] += 1
                scan_results['summary']['total_vulnerabilities'] += 1
                
        except Exception as e:
            logging.error(f"Error in scan_website: {str(e)}")
            
        return scan_results
